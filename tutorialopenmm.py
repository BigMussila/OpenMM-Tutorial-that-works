# -*- coding: utf-8 -*-
"""TutorialOpenMM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IcBbcMitmFLbcSaIOow0iVpnWMyEPfYJ

# Instalando bibliotecas importantes

Altere o tipo de ambiente de execução para T4
"""

!pip install biopython
!pip install py3Dmol
!pip install simtk
!pip install MDAnalysis
!pip install -q condacolab

"""# Instalando o OpenMM em um ambiente conda no colab"""

import condacolab
condacolab.install()
!conda install -c conda-forge openmm

"""Verificando instalação do OpenMM"""

!python -m openmm.testInstallation

import sys
import openmm
from openmm import *
from openmm.app import *
from openmm.unit import *
import os
from sys import stdout
from simtk.openmm.app import PDBFile


import py3Dmol

"""# 1- Importando arquivo pdb"""

!wget http://www.rcsb.org/pdb/files/6YG9.pdb.gz
  !gunzip 6YG9.pdb.gz

"""# Primeira modelagem... Vai dar erro"""

# Insira o padding e o pH
pH = 7
Padding = 0.5
iS = 0.15 # ionicStrength (Força Ionica)

print('Loading...')
pdb = PDBFile('6YG9.pdb') # colocar aqui o pdb arrumado
forcefield = ForceField('amber99sb.xml', 'tip3p.xml')
modeller = Modeller(pdb.topology, pdb.positions)
modeller.deleteWater()

print('Adding hydrogens...')
modeller.addHydrogens(forcefield, pH= pH) # Aqui altera pH

# print('Adding membrane...')
# modeller.addMembrane(forcefield, lipidType='POPC', minimumPadding=1*nanometer)

print('Adding solvent...')
modeller.addSolvent(forcefield, model='tip3p', boxShape='octahedron', ionicStrength =iS*molar, padding= Padding*nanometer) #Aqui altera padding, força inonica, colocar ions...

print('Saving...')

PDBFile.writeFile(modeller.topology, modeller.positions, open(f'{Padding}nm_pH{pH}_iS{iS}nm_.pdb', 'w'))
print('Done')

"""Para resolver o erro vamos instalar o pdbfixer que adiciona os atomos que faltam na estrutura pdb"""

!conda install -c conda-forge pdbfixer

"""Função para arrumando atomos de cada resíduo"""

from pdbfixer import PDBFixer
import os
def fix_pdb(pdb_id):
    path = os.getcwd()
    if len(pdb_id) != 4:
        pH = 7 # ALTERAR pH AQUI
        print("Creating PDBFixer...")
        fixer = PDBFixer(pdb_id)
        print("Finding missing residues...")
        fixer.findMissingResidues()

        chains = list(fixer.topology.chains())
        keys = fixer.missingResidues.keys()
        for key in list(keys):
            chain = chains[key[0]]
            if key[1] == 0 or key[1] == len(list(chain.residues())):
                print("ok")
                del fixer.missingResidues[key]

        print("Finding nonstandard residues...")
        fixer.findNonstandardResidues()
        print("Replacing nonstandard residues...")
        fixer.replaceNonstandardResidues()
        print("Removing heterogens...")
        fixer.removeHeterogens(keepWater=True)

        print("Finding missing atoms...")
        fixer.findMissingAtoms()
        print("Adding missing atoms...")
        fixer.addMissingAtoms()
        print("Adding missing hydrogens...")
        fixer.addMissingHydrogens(7)
        print("Writing PDB file...")

        PDBFile.writeFile(
            fixer.topology,
            fixer.positions,
            open(os.path.join(path, "%s_fixed_pH_%s.pdb" % (pdb_id.split('.')[0], pH)),
                 "w"),
            keepIds=True)
        return "%s_fixed_pH_%s.pdb" % (pdb_id.split('.')[0], pH)

fix_pdb('amostra.pdb') #ALTERAR AQUI

"""# 2- Modelando com o novo pdb ajustado

Mais informações: http://docs.openmm.org/latest/userguide/application/03_model_building_editing.html
"""

# Insira o padding e o pH
pH = 7
Padding = 1
iS = 0.15 # ionicStrength (Força Ionica)

print('Loading...')
pdb = PDBFile('6YG9_fixed_pH_7.pdb') # colocar aqui o pdb arrumado
forcefield = ForceField('amber99sb.xml', 'tip3p.xml')
modeller = Modeller(pdb.topology, pdb.positions)
modeller.deleteWater()

print('Adding hydrogens...')
modeller.addHydrogens(forcefield, pH= pH) # Aqui altera pH

# print('Adding membrane...')
# modeller.addMembrane(forcefield, lipidType='POPC', minimumPadding=1*nanometer)

print('Adding solvent...')
#modeller.addSolvent(forcefield, model='tip3p', boxShape='octahedron', ionicStrength =iS*molar, padding= Padding*nanometer) #Aqui altera padding, força inonica, colocar ions...

print('Saving...')

PDBFile.writeFile(modeller.topology, modeller.positions, open(f'{Padding}nm_pH{pH}_iS{iS}.pdb', 'w'))
print('Done')

"""Visualizando a modelagem"""

import py3Dmol

#First we assign the py3Dmol.view as view
view=py3Dmol.view()
#The following lines are used to add the addModel class

#to read the PDB files of chains Albumin
view.addModel(open(f'{Padding}nm_pH{pH}_iS{iS}.pdb', 'r').read(),'pdb', {'keepH':'true'}) #Manter Hidrogenios

# Estilos de visualização
# view.setStyle({'chain':'A'},{'cartoon': {'color':'red'}})
view.setStyle({'chain':'A'},{'cartoon': {'color':'spectrum'}})
#view.setStyle({'chain':'B'},{'cartoon': {'color':'yellow'}}) # Se tiver mais de uma cadeia
view.setStyle({'chain':'C'},{'stick': {'color':'blue'}})
view.setStyle({'resn':'NA'},{'sphere': {'color':'purple'}})
view.setStyle({'resn':'CL'},{'sphere': {'color':'green'}})

#Zooming into all visualized structures
view.zoomTo()
#Here we set the background color as white
view.setBackgroundColor('white')
#And we finally visualize the structures using the command below
view.show()

"""# 3- Minimização de energia

"""

print('Minimizing...')
system = forcefield.createSystem(modeller.topology, nonbondedMethod=PME)
integrator = VerletIntegrator(0.001*picoseconds)
simulation = Simulation(modeller.topology, system, integrator)
simulation.context.setPositions(modeller.positions)
simulation.minimizeEnergy(tolerance=0.1*kilojoule_per_mole/(nanometer))
simulation.reporters.append(StateDataReporter('energy.csv', # Nome do arquivo
                                              1000, step=True, # Muda a frequencia de interações com que é salvo as informações na tabela
                                    potentialEnergy=True ,totalEnergy=True, temperature=True))  # Salvar dados de energia
simulation.step(10000) # ALTERAR AS INTERAÇÕES
print('Saving...')
positions = simulation.context.getState(getPositions=True).getPositions()
PDBFile.writeFile(simulation.topology, positions, open('minimized_10000.pdb', 'w'))
print('Done')

"""Gráfico da Energia Potencial do sistema"""

import pandas as pd
import matplotlib.pyplot as plt

# Carregar os dados do arquivo CSV usando o Pandas
df = pd.read_csv('energy.csv')

# Extrair os dados de energia total
energias = df['Potential Energy (kJ/mole)']

# Criar array de passos (steps)
steps = df['#"Step"']

# Plotar gráfico
plt.plot(steps, energias, label='Energia Potencial', color='blue', linestyle='-')
plt.scatter(steps, energias, color='red', marker='o', label='Pontos')
plt.xlabel('Interações')
plt.ylabel('Energia Potencial (kJ/mol)')
plt.title('Evolução da Energia Potencial durante a Minimização')
plt.legend()
plt.show()

"""Gráfico da Energia Total do sistema"""

import numpy as np

# Carregar os dados do arquivo CSV usando o Pandas
df = pd.read_csv('energy.csv')

# Extrair os dados de energia total
energias = df['Total Energy (kJ/mole)']

# Criar array de passos (steps)
steps = df['#"Step"']

# Plotar gráfico
plt.plot(steps, energias, label='Energia Total', color='blue', linestyle='-')
plt.scatter(steps, energias, color='red', marker='o', label='Pontos')
plt.xlabel('Interações')
plt.ylabel('Energia Total (kJ/mol)')
plt.title('Evolução da Energia Total durante a Minimização')
plt.legend()
plt.show()

"""Sobrepondo a estrutura modelada e a *minimizada*"""

#The following code was created by Anders Steen Christensen
#from the University of Basel and is available at
#https://gist.github.com/andersx/6354971

# The following code was optimized by Débora Cristina from the Federal University of Rio Grande do Sul

import Bio.PDB
import os

# Start the parser
pdb_parser = Bio.PDB.PDBParser(QUIET = True)

pdbIDref = '6YG9_fixed_pH_7' # Altere aqui o PDB referencia
pdbIDsample = 'minimized_10000' # Altere aqui o PDB amostral

# Get the structures
ref_structure = pdb_parser.get_structure("reference", f'{pdbIDref}.pdb')

sample_structure = pdb_parser.get_structure("sample", f"{pdbIDsample}.pdb")

# Holder lists for the atoms
ref_atoms = []
sample_atoms = []

# Getting atoms
struct_ref_atoms = ref_structure.get_atoms()
for atom in struct_ref_atoms:
  ref_atoms.append(atom)

struct_sample_atoms = sample_structure.get_atoms()
for atom in struct_sample_atoms:
  sample_atoms.append(atom)

# trials i made to find out what i was doing
print(type(ref_atoms[0]))
print(len(ref_atoms))
print(len(sample_atoms))

# Now we initiate the superimposer:
super_imposer = Bio.PDB.Superimposer()
super_imposer.set_atoms(ref_atoms, sample_atoms)
super_imposer.apply(sample_model.get_atoms())

# Print RMSD:
print("The calculated RMSD for the ref and it's minimized energy is:")
if super_imposer.rms > 0.01:
  print(str(super_imposer.rms) + ' Å')
else:
  print("0.00 Å")

# Save the aligned version of one of the chains
io = Bio.PDB.PDBIO()
io.set_structure(sample_structure)
io.save(f"{pdbIDref}_{pdbIDsample}_aligned.pdb")

"""# 4- EQUILIBRAÇÃO

Etapa 1: Restringindo posições da proteína com **5.000**kJ/mo
"""

# Carregar o arquivo PDB
pdb = PDBFile('/content/minimized_10000.pdb')
forcefield = ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')

# Criar o sistema com as restrições
system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)

# Adicionar restrições de posição aos átomos CA
restraint = CustomExternalForce('k*periodicdistance(x, y, z, x0, y0, z0)^2')
system.addForce(restraint)
restraint.addGlobalParameter('k', 1000.0*kilojoules_per_mole/nanometer**2)
restraint.addPerParticleParameter('x0')
restraint.addPerParticleParameter('y0')
restraint.addPerParticleParameter('z0')

for atom in pdb.topology.atoms():
    if atom.name == 'CA':
        restraint.addParticle(atom.index, pdb.positions[atom.index])
system.addForce(restraint)

"""Etapa 2: Equilibração **NVT** 100ps com **5.000**kJ/mol de restrição de posição"""

# Equilibração NVT com restrições de posição
print('Equilibrando NVT...')
nvt_integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation = Simulation(pdb.topology, system, nvt_integrator)
simulation.context.setPositions(pdb.positions)
simulation.reporters.append(StateDataReporter('nvt_equilibration.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000

# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
pdb = PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NVT_5000.pdb', 'w'))

"""Etapa 3: Equilibração **NPT** 100ps com **5.000**kJ/mol de restrição de posição"""

# Equilibração NPT com restrições de posição (5000 kJ/mol)
print('Equilibrando NPT com 5000 kJ/mol de restrição de posição...')
system.addForce(MonteCarloBarostat(1 * bar, 310 * kelvin))
npt_integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation.context.setPositions(final_positions)
simulation.reporters.append(StateDataReporter('npt_equilibration_5000.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000

# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
pdb = PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NPT_5000.pdb', 'w'))

"""Etapa 4: Restringindo posições da proteína com **1.000**kJ/mol"""

# Criar o sistema com as restrições
pdb = PDBFile('equilibrated_NPT_5000.pdb')
system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)

# Adicionar restrições de posição aos átomos CA
restraint_force = CustomExternalForce('0.5*k*((x-x0)^2+(y-y0)^2+(z-z0)^2)')
restraint_force.addPerParticleParameter('k')
restraint_force.addPerParticleParameter('x0')
restraint_force.addPerParticleParameter('y0')
restraint_force.addPerParticleParameter('z0')
for atom in pdb.topology.atoms():
    if atom.name == 'CA':
        restraint_force.addParticle(atom.index, [1000.0*kilojoule_per_mole/nanometer**2,
                                                 pdb.positions[atom.index][0],
                                                 pdb.positions[atom.index][1],
                                                 pdb.positions[atom.index][2]])
system.addForce(restraint_force)

"""Etapa 5: Equilibração **NPT** 100ps com **1.000**kJ/mol de restrição de posição"""

# Equilibração NPT com restrições de posição (1000 kJ/mol)
print('Equilibrando NPT com 1000 kJ/mol de restrição de posição...')
# Adicionar a restrição ao sistema
system.addForce(MonteCarloBarostat(1 * bar, 310 * kelvin))

npt_integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation = Simulation(pdb.topology, system, npt_integrator)
simulation.context.setPositions(final_positions)
simulation.reporters.append(StateDataReporter('npt_equilibration_1000.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000

# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
pdb = PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NPT_1000.pdb', 'w'))

print('Equilibração completa')

"""# Dinâmica molecular de Produção"""

# Dinâmica molecular de produção (2000 ps) ou 2ns

# Salvar as posições finais em um arquivo PDB
pdb = PDBFile('equilibrated_NPT_1000.pdb')
forcefield = ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')
system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)
final_positions = pdb.positions

print('Produção...')
production_integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation = Simulation(pdb.topology, system, production_integrator)
simulation.context.setState(state)

state = simulation.context.getState(getPositions=True, getVelocities=True)
final_positions = state.getPositions()

simulation.reporters.append(StateDataReporter('production.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.reporters.append(PDBReporter('production.pdb', 1000))
simulation.step(500000)  # 2000 ps -> 2000 ps / 0,004 = 500000

print('Dinâmica completa')

"""# Equilibrações + DM"""

# Carregar o arquivo PDB
pdb = PDBFile('minimized_10000.pdb')
forcefield = ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')

# Criar o sistema com as restrições
system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)

# Adicionar restrições de posição aos átomos CA
restraint = CustomExternalForce('k*periodicdistance(x, y, z, x0, y0, z0)^2')
system.addForce(restraint)
restraint.addGlobalParameter('k', 5000.0*kilojoules_per_mole/nanometer**2)
restraint.addPerParticleParameter('x0')
restraint.addPerParticleParameter('y0')
restraint.addPerParticleParameter('z0')

for atom in pdb.topology.atoms():
    if (atom.name == 'CA'):
        restraint.addParticle(atom.index, pdb.positions[atom.index])

# Equilibração NVT com restrições de posição
print('Equilibrando NVT...')
integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation = Simulation(pdb.topology, system, integrator)
simulation.context.setPositions(pdb.positions)
simulation.reporters.append(StateDataReporter('nvt_equilibration.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000

# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True, getVelocities=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NVT_5000.pdb', 'w'))

# Equilibração NPT com restrições de posição (5000 kJ/mol)
print('Equilibrando NPT com 5000 kJ/mol de restrição de posição...')
system.addForce(MonteCarloBarostat(1 * bar, 310 * kelvin))
integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation.context.setState(state)
simulation.reporters.append(StateDataReporter('npt_equilibration_5000.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000

# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True, getVelocities=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NPT_5000.pdb', 'w'))

# Adicionar restrições de posição aos átomos CA
restraint = CustomExternalForce('k*periodicdistance(x, y, z, x0, y0, z0)^2')
system.addForce(restraint)
restraint.addGlobalParameter('k', 1000.0*kilojoules_per_mole/nanometer**2)
restraint.addPerParticleParameter('x0')
restraint.addPerParticleParameter('y0')
restraint.addPerParticleParameter('z0')

for atom in pdb.topology.atoms():
    if (atom.name == 'CA'):
        restraint.addParticle(atom.index, pdb.positions[atom.index])

# Equilibração NPT com restrições de posição (1000 kJ/mol)
print('Equilibrando NPT com 1000 kJ/mol de restrição de posição...')
system.addForce(MonteCarloBarostat(1 * bar, 310 * kelvin))
integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.004*picoseconds)
simulation.context.setState(state)
simulation.reporters.append(StateDataReporter('npt_equilibration_1000.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.step(25000)  # 100 ps -> 100 ps / 0,004 = 25000


# Carregar o último estado da simulação após a equilibração
state = simulation.context.getState(getPositions=True, getVelocities=True)
final_positions = state.getPositions()
# Salvar as posições finais em um arquivo PDB
PDBFile.writeFile(simulation.topology, final_positions, open('equilibrated_NPT_1000.pdb', 'w'))

print('Equilibração completa')


# Dinâmica molecular de produção (2000 ps) ou 2ns

# Salvar as posições finais em um arquivo PDB
pdb = PDBFile('equilibrated_NPT_1000.pdb')
forcefield = ForceField('amber14-all.xml', 'amber14/tip3pfb.xml')
system = forcefield.createSystem(pdb.topology, nonbondedMethod=PME, nonbondedCutoff=1*nanometer, constraints=HBonds)
final_positions = pdb.positions

print('Produção...')
production_integrator = LangevinMiddleIntegrator(310*kelvin, 1/picosecond, 0.002*picoseconds)
simulation = Simulation(pdb.topology, system, production_integrator)
simulation.context.setState(state)

state = simulation.context.getState(getPositions=True, getVelocities=True)
final_positions = state.getPositions()

simulation.reporters.append(StateDataReporter('production.csv', 1000, step=True, potentialEnergy=True, temperature=True, volume=True, density=True))
simulation.reporters.append(PDBReporter('production.pdb', 1000))
simulation.step(500000)  # 1 ns -> 1000 ps / 0,002 = 500000

print('Dinâmica completa')

"""Passando pdb da DM para o Drive"""

from google.colab import drive
drive.mount('/content/drive')

import locale
locale.getpreferredencoding = lambda: "UTF-8"

# Criar a pasta no Google Drive se ela não existir
!mkdir -p /content/drive/MyDrive/MyProject

# Copy the file to Google Drive with locale settings
!cp production.pdb /content/drive/MyDrive/MyProject/
!cp production.csv /content/drive/MyDrive/MyProject/

"""# Analisando dados da Equilibração

"""

import pandas as pd
import matplotlib.pyplot as plt

# Função para plotar os dados
def plot_simulation_data(csv_file, title):
    # Carregar dados do arquivo CSV usando Pandas
    data = pd.read_csv(csv_file, delimiter=',', quotechar='"')

    # Extrair os dados necessários
    steps = data['#"Step"']
    potential_energy = data['Potential Energy (kJ/mole)']
    temperature = data['Temperature (K)']
    volume = data['Box Volume (nm^3)']
    density = data['Density (g/mL)']

    # Plotar os dados
    fig, axs = plt.subplots(3, figsize=(10, 12))

    axs[0].plot(steps, potential_energy, label='Potential Energy')
    axs[0].scatter(steps, potential_energy, color='red', marker='o', label='Pontos')  # Adicionando pontos vermelhos
    axs[0].set_ylabel('Potential Energy (kJ/mol)')
    axs[0].set_title(title)
    axs[0].legend()

    axs[1].plot(steps, volume, label='Box Volume (nm^3)')
    axs[1].scatter(steps, volume, color='red', marker='o', label='Pontos')  # Adicionando pontos vermelhos
    axs[1].set_ylabel('Volume (nm^3)')
    axs[1].legend()

    axs[2].plot(steps, density, label='Density (g/mL)')
    axs[2].scatter(steps, density, color='red', marker='o', label='Pontos')  # Adicionando pontos vermelhos
    axs[2].set_xlabel('Steps')
    axs[2].set_ylabel('Density (g/mL)')
    axs[2].legend()

    plt.tight_layout()
    plt.show()

# Exemplo de uso
csv_file = 'nvt_equilibration_3.csv'  # Substitua com o caminho correto para o seu arquivo CSV
plot_simulation_data(csv_file, 'Equilibração NVT')

csv_file = 'npt_equilibration_5000_3.csv'  # Substitua com o caminho correto para o seu arquivo CSV
plot_simulation_data(csv_file, 'Equilibração NPT 5000')

csv_file = 'npt_equilibration_1000_3.csv'  # Substitua com o caminho correto para o seu arquivo CSV
plot_simulation_data(csv_file, 'Equilibração NPT 1000')

csv_file = 'production_3.csv'  # Substitua com o caminho correto para o seu arquivo CSV
plot_simulation_data(csv_file, 'DM')

"""# Analisando dados da DM

Análise de RMSD durante a simulação
"""

from google.colab import drive
drive.mount('/content/drive')

import MDAnalysis as mda
from MDAnalysis.analysis import rms
import pandas as pd
import matplotlib.pyplot as plt

# Carregando a trajetória e o arquivo de referência
u_dynamic = mda.Universe('/content/drive/MyDrive/MyProject/production.pdb')
u_reference = mda.Universe('6YG9_fixed_pH_7.pdb')

# Executando a análise de RMSD para o backbone da proteína
R_backbone = rms.RMSD(u_dynamic, u_reference, select='backbone', groupselections=['protein'], ref_frame=0)
R_backbone.run()

# Executando a análise de RMSD para átomos de CA
R_CA = rms.RMSD(u_dynamic, u_reference, select='name CA', groupselections=['protein'], ref_frame=0)
R_CA.run()

# Executando a análise de RMSD para toda a proteína (todos os átomos de proteína)
R_protein = rms.RMSD(u_dynamic, u_reference, select='protein', groupselections=['protein'], ref_frame=0)
R_protein.run()

# Criando DataFrames com os resultados de RMSD
df_backbone = pd.DataFrame(R_backbone.results.rmsd, columns=['Frame', 'Time (ns)', 'Backbone', 'Protein'])
df_CA = pd.DataFrame(R_CA.results.rmsd, columns=['Frame', 'Time (ns)', 'CA', 'Protein'])
df_protein = pd.DataFrame(R_protein.results.rmsd, columns=['Frame', 'Time (ns)', 'Protein', 'Protein'])

# Plotando o RMSD de backbone, átomos de CA e toda a proteína juntos
plt.figure(figsize=(10, 6))

plt.plot(df_backbone['Frame'], df_backbone['Backbone'], label='Backbone')
plt.plot(df_CA['Frame'], df_CA['CA'], label='CA')
plt.plot(df_protein['Frame'], df_protein['Protein'], label='Protein')

plt.ylabel(r'RMSD ($\AA$)')
plt.xlabel('Step')
plt.title('RMSD Comparação Backbone vs CA vs Proteína')
plt.legend()
plt.grid(True)

plt.savefig('RMSD_backbone_CA_proteina.png')
plt.show()

"""Análise de RMSF durante a simulação"""

import MDAnalysis as mda
from MDAnalysis.analysis import align, rms
import matplotlib.pyplot as plt

# Carregando a trajetória
u = mda.Universe('/content/drive/MyDrive/MyProject/production.pdb')

# Criando estrutura média a partir do frame 0 da trajetória
average = align.AverageStructure(u, u, select='protein and name CA', ref_frame=0).run()
ref = average.results.universe

# Alinhando todos os frames da trajetória com a estrutura média
aligner = align.AlignTraj(u, ref, select='protein and name CA', in_memory=True).run()

# Calculando o RMSF
c_alphas = u.select_atoms('protein and name CA')
R = rms.RMSF(c_alphas).run()

# Plotando o RMSF e salvando em um arquivo
plt.plot(c_alphas.resids, R.results.rmsf)
plt.xlabel('Residuo')
plt.ylabel('RMSF ($\AA$)')
plt.title('RMSF')
plt.ylim(0, 1.5)  # Altere os limites do eixo y conforme necessário
plt.savefig('RMSF.png')
plt.show()